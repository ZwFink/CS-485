% Gemini theme
% https://github.com/anishathalye/gemini

\documentclass[final]{beamer}

% ====================
% Packages
% ====================

\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage[size=custom,width=120,height=72,scale=1.0]{beamerposter}
\usetheme{gemini}
\usecolortheme{gemini}
\usepackage{graphicx}
\usepackage{booktabs}
\usepackage{tikz}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{pgfplots}
\usepackage{tabularx}

% ====================
% Lengths
% ====================

% If you have N columns, choose \sepwidth and \colwidth such that
% (N+1)*\sepwidth + N*\colwidth = \paperwidth
\newlength{\sepwidth}
\newlength{\colwidth}
\setlength{\sepwidth}{0.025\paperwidth}
\setlength{\colwidth}{0.3\paperwidth}

\newcommand{\separatorcolumn}{\begin{column}{\sepwidth}\end{column}}

% ====================
% Control Sequences
% ====================

%\def\DtoH{\textit{DtoH}\xspace}
%\def\HtoD{\textit{HtoD}\xspace}

\def\DtoH{\textit{DtoH}}
\def\HtoD{\textit{HtoD}}

% ====================
% Title
% ====================

\title{Accelerating the Unacceleratable: Hybrid CPU/GPU Algorithms\\ for Memory-Bound Database Primitives}

\author{Michael Gowanlock\inst{1}, Ben Karsin\inst{2}, Zane Fink\inst{1}, and Jordan Wright\inst{1}}

\institute[shortinst]{\inst{1} School of Informatics, Computing, and Cyber Systems at Northern Arizona University}
\institute[shortinst]{\inst{2} Department of Computer Science at Universite libre de Bruxelles}

% ====================
% Body
% ====================

\begin{document}

\begin{frame}[t]
\begin{columns}[t]
\separatorcolumn

\begin{column}{\colwidth}

  \begin{block}{Abstract}

   Many database operations have a low compute to memory access ratio. 
   In heterogeneous systems, where a graphics processing unit (GPU) is interconnected via PCIe, 
   the data transfer bottleneck is perceived as insurmountable to achieving performance gains 
   on these memory-bound database primitives. On the other hand, several compute-bound database 
   operations have been shown to achieve significant performance gains using the GPU.  
   This leads to CPU-only memory-bound applications having an increasingly non-negligible impact 
   on database query throughput. In this paper we examine several of these overlooked algorithms, 
   including $(i)$ batched predecessor searches; $(ii)$ multiway merging; and, $(iii)$ partitioning. 
   We examine the performance of parallel CPU-only, GPU-only, and hybrid CPU/GPU approaches, and show 
   that hybrid algorithms achieve respectable performance gains. We develop a model that considers 
   main memory accesses and PCIe data transfers, which are two major bottlenecks for hybrid CPU/GPU algorithms. 
   The model lets us analytically determine how to distribute work between the CPU and GPU to maximize resource 
   utilization while minimizing load imbalance. We show that our model can accurately predict the fraction of work 
   to be sent to each architecture, and consequently, confirms that these overlooked database primitives can be 
   accelerated despite their memory-bound nature. 

  \end{block}

  \begin{block}{Introduction}
    
   


    \begin{table}[htp]
    
    \centering
    \begin{footnotesize}
    \caption{Summary of algorithms considered in this paper, total elements loaded/stored from main memory, 
             and asymptotic time complexity in the RAM model.  We omit small additive terms for loads/stores and, 
             for the GPU, we compute it as the maximum unidirectional data transferred, since we overlap data transfers.  
             The parameter $\mu$ depends on the hardware which is optimized experimentally.} 
    \label{tab:algorithms}
    \begin{tabularx}{\columnwidth}{|l|l|X|X|} \hline
    Algorithm& Arch. & Elements accessed in memory & RAM Complexity \\ \hline
    Batched Pred. Search & CPU& $3n$ & $O(n)$ \\
    \hline
    Batched Pred. Search & GPU& $2n$ & $O(n\log{n})$ \\\hline
    Multiway Merge & CPU& $2n$ & $O(n\log{k})$ \\\hline
    Multiway Merge & GPU& $n$ & $O(n\log{k})$ \\\hline
    $k$-way Partition               & CPU& $2n\lceil\log_{\mu}{k}\rceil$ & $O(n\log{k})$ \\\hline
    $k$-way Partition               & GPU& $n$ & $O((n+n_bk) \log{\frac{n}{n_b}})$ \\
    \hline
    \end{tabularx}
    \end{footnotesize}

    \end{table}

  \end{block}

  \begin{alertblock}{Problem Statement}

   For each of our database primitives we implement CPU-only, GPU-only, and hybrid CPU/GPU algorithms. 
   We consider a platform with multi-core CPUs and a GPU, where the total response time includes all 
   data transfers to and from the GPU and related overheads. The final result of each algorithm is 
   stored in main memory. We assume that each algorithm can exceed the GPU's global memory capacity. 
   However, each algorithm may not exceed main memory capacity, as we do not consider the impact of disk accesses in this work.

  \end{alertblock}

\end{column}

\separatorcolumn

\begin{column}{\colwidth}

  \begin{block}{Hybrid Algorithms}

   We use the notation in Table~\ref{tab:notation} when describing our algorithms. 
   \begin{table}[htp]
   \centering
   \begin{footnotesize}
   \caption{Summary of notation and descriptions.}\label{tab:notation}
   \begin{tabularx}{\columnwidth}{|l|X|} \hline
      & Description\\ \hline
   $n$& Input size.\\ \hline
   $p$ & The number of CPU cores.\\\hline
   $\alpha$ & Measured read/write bandwidth between CPU and main memory for the CPU component of a hybrid algorithm. \\\hline
   $\beta$  & Measured unidirectional bandwidth between the GPU's global memory and main memory over PCIe.\\\hline
   $\mu$ & Number of partition buckets in a single pass.  The parameter is a function of the memory system and we optimize it experimentally.  \\\hline
   $n_b$ & The number of batches. The total work is divided into these disjoint independent workloads. \\\hline
   \HtoD & A data transfer from host to device.\\\hline
   \DtoH & A data transfer from device to host.\\\hline
   \end{tabularx}
   \end{footnotesize}
   \end{table}


   \heading{Batched Predecessor Search}
   
   We outline the batched predecessor search as follows. Let $A$ be a set of keys sorted in non-decreasing order,  
   where each key is denoted as $a_i$, where $i=1, 2,\ldots,n$, and $B$ be a set of queries sorted in non-decreasing order, 
   where each query is denoted as $b_j$, where $j=1, 2,\ldots,n$. For each query, $b_j\in B$, the batched predecessor search 
   finds the largest value of $i$, such that $a_i\leq b_j$. While $A$ and $B$ can vary in size, for simplicity, we assume $|A|=|B|=n$.

   \heading{Multiway Merging}

   We define the problem of \emph{multiway merging} as follows.  Given input array $A$ consisting of $k$ sublists, denoted as $S_j$, 
   where $j=1, 2,\ldots,k$, each of size  $\frac{n}{k}$ and sorted in non-decreasing order, we wish to output the $n$ total elements 
   in sorted order. Furthermore, we assume that $k$ is small enough that we can load elements 
   from each sublist into memory without degrading CPU cache utilization.

   \heading{Partitioning}

We consider the problem of \emph{$k$-way partitioning} (or simply partitioning).  Given an unsorted list, $A$, of $n$ elements, we wish to partition $A$ into $k$ buckets $A_1, A_2, \ldots, A_k$ of roughly equal size such that each bucket is value-disjoint.  That is, for any two elements $a \in A_i$ and $b \in A_j$, if $i < j$, then $a<b$.  This problem is also known as \emph{distribution} and is a subroutine of many algorithms, including distribution sort (also known as multiway quicksort).  In the RAM and EM models, the lower bounds for partitioning $n$ elements into $k$ buckets is $O(n \log{k})$ and $O(\frac{n}{B}\log_{M/B}{k})$, respectively.  The external memory bound can be achieved by repeatedly partitioning $n$ into $\frac{M}{B}$ buckets (which can be done in a single I/O-efficient scan).  
We note that if $k=n$, partitioning is equivalent to sorting. 

Partitioning involves $(i)$ finding pivots for each bucket ($k$ total); $(ii)$ determining which bucket each element is in; and, $(iii)$ moving each element into contiguous memory with other elements in the same bucket.  Since we focus on the memory-bound ``bucketing'' portion of the problem, we assume that the pivots are given and no more than a constant factor more than $\frac{n}{k}$ elements will end up in any bucket.


  \end{block}

  \begin{block}{Fusce aliquam magna velit}

    Et rutrum ex euismod vel. Pellentesque ultricies, velit in fermentum
    vestibulum, lectus nisi pretium nibh, sit amet aliquam lectus augue vel
    velit. Suspendisse rhoncus massa porttitor augue feugiat molestie. Sed
    molestie ut orci nec malesuada. Sed ultricies feugiat est fringilla
    posuere.

    \begin{figure}
      \centering
      \begin{tikzpicture}
        \begin{axis}[
            scale only axis,
            no markers,
            domain=0:2*pi,
            samples=100,
            axis lines=center,
            axis line style={-},
            ticks=none]
          \addplot[red] {sin(deg(x))};
          \addplot[blue] {cos(deg(x))};
        \end{axis}
      \end{tikzpicture}
      \caption{Another figure caption.}
    \end{figure}

  \end{block}

  \begin{block}{Nam cursus consequat egestas}

    Nulla eget sem quam. Ut aliquam volutpat nisi vestibulum convallis. Nunc a
    lectus et eros facilisis hendrerit eu non urna. Interdum et malesuada fames
    ac ante \textit{ipsum primis} in faucibus. Etiam sit amet velit eget sem
    euismod tristique. Praesent enim erat, porta vel mattis sed, pharetra sed
    ipsum. Morbi commodo condimentum massa, \textit{tempus venenatis} massa
    hendrerit quis. Maecenas sed porta est. Praesent mollis interdum lectus,
    sit amet sollicitudin risus tincidunt non.

    Etiam sit amet tempus lorem, aliquet condimentum velit. Donec et nibh
    consequat, sagittis ex eget, dictum orci. Etiam quis semper ante. Ut eu
    mauris purus. Proin nec consectetur ligula. Mauris pretium molestie
    ullamcorper. Integer nisi neque, aliquet et odio non, sagittis porta justo.

    \begin{itemize}
      \item \textbf{Sed consequat} id ante vel efficitur. Praesent congue massa
        sed est scelerisque, elementum mollis augue iaculis.
        \begin{itemize}
          \item In sed est finibus, vulputate
            nunc gravida, pulvinar lorem. In maximus nunc dolor, sed auctor eros
            porttitor quis.
          \item Fusce ornare dignissim nisi. Nam sit amet risus vel lacus
            tempor tincidunt eu a arcu.
          \item Donec rhoncus vestibulum erat, quis aliquam leo
            gravida egestas.
        \end{itemize}
      \item \textbf{Sed luctus, elit sit amet} dictum maximus, diam dolor
        faucibus purus, sed lobortis justo erat id turpis.
      \item \textbf{Pellentesque facilisis dolor in leo} bibendum congue.
        Maecenas congue finibus justo, vitae eleifend urna facilisis at.
    \end{itemize}

  \end{block}

\end{column}

\separatorcolumn

\begin{column}{\colwidth}

  \begin{block}{A block containing some math}

    Nullam non est elit. In eu ornare justo. Maecenas porttitor sodales lacus,
    ut cursus augue sodales ac.

    $$
    \int_{-\infty}^{\infty} e^{-x^2}\,dx = \sqrt{\pi}
    $$

    Interdum et malesuada fames $\{1, 4, 9, \ldots\}$ ac ante ipsum primis in
    faucibus. Cras eleifend dolor eu nulla suscipit suscipit. Sed lobortis non
    felis id vulputate.

    \heading{A heading inside a block}

    Praesent consectetur mi $x^2 + y^2$ metus, nec vestibulum justo viverra
    nec. Proin eget nulla pretium, egestas magna aliquam, mollis neque. Vivamus
    dictum $\mathbf{u}^\intercal\mathbf{v}$ sagittis odio, vel porta erat
    congue sed. Maecenas ut dolor quis arcu auctor porttitor.

    \heading{Another heading inside a block}

    Sed augue erat, scelerisque a purus ultricies, placerat porttitor neque.
    Donec $P(y \mid x)$ fermentum consectetur $\nabla_x P(y \mid x)$ sapien
    sagittis egestas. Duis eget leo euismod nunc viverra imperdiet nec id
    justo.

  \end{block}

  \begin{block}{Nullam vel erat at velit convallis laoreet}

    Class aptent taciti sociosqu ad litora torquent per conubia nostra, per
    inceptos himenaeos. Phasellus libero enim, gravida sed erat sit amet,
    scelerisque congue diam. Fusce dapibus dui ut augue pulvinar iaculis.

    \begin{table}
      \centering
      \begin{tabular}{l r r c}
        \toprule
        \textbf{First column} & \textbf{Second column} & \textbf{Third column} & \textbf{Fourth} \\
        \midrule
        Foo & 13.37 & 384,394 & $\alpha$ \\
        Bar & 2.17 & 1,392 & $\beta$ \\
        Baz & 3.14 & 83,742 & $\delta$ \\
        Qux & 7.59 & 974 & $\gamma$ \\
        \bottomrule
      \end{tabular}
      \caption{A table caption.}
    \end{table}

    Donec quis posuere ligula. Nunc feugiat elit a mi malesuada consequat. Sed
    imperdiet augue ac nibh aliquet tristique. Aenean eu tortor vulputate,
    eleifend lorem in, dictum urna. Proin auctor ante in augue tincidunt
    tempor. Proin pellentesque vulputate odio, ac gravida nulla posuere
    efficitur. Aenean at velit vel dolor blandit molestie. Mauris laoreet
    commodo quam, non luctus nibh ullamcorper in. Class aptent taciti sociosqu
    ad litora torquent per conubia nostra, per inceptos himenaeos.

    Nulla varius finibus volutpat. Mauris molestie lorem tincidunt, iaculis
    libero at, gravida ante. Phasellus at felis eu neque suscipit suscipit.
    Integer ullamcorper, dui nec pretium ornare, urna dolor consequat libero,
    in feugiat elit lorem euismod lacus. Pellentesque sit amet dolor mollis,
    auctor urna non, tempus sem.

  \end{block}

  \begin{block}{References}

    \nocite{*}
    \footnotesize{\bibliographystyle{plain}\bibliography{poster}}

  \end{block}

\end{column}

\separatorcolumn
\end{columns}
\end{frame}

\end{document}
